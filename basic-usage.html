<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Basic Usage</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script><script>

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-39680853-6', 'auto');
  ga('send', 'pageview');

</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Infix</span> <span class="project-version">0.3.3</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="basic-usage.html"><div class="inner"><span>Basic Usage</span></div></a></li><li class="depth-1 "><a href="references.html"><div class="inner"><span>References</span></div></a></li><li class="depth-1 "><a href="LICENSE.html"><div class="inner"><span>The MIT License (MIT)</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>infix</span></div></div></li><li class="depth-2 branch"><a href="infix.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="infix.grammar.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>grammar</span></div></a></li><li class="depth-2 branch"><a href="infix.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-2"><a href="infix.math.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>math</span></div></a></li><li class="depth-3 branch"><a href="infix.math.bit-shuffling.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bit-shuffling</span></div></a></li><li class="depth-3 branch"><a href="infix.math.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-3 branch"><a href="infix.math.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><a href="infix.math.trig.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>trig</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#basic-usage" name="basic-usage"></a>Basic Usage</h1>
<pre><code class="clojure">(refer 'infix.macros :only '[infix from-string base-env])
; =&gt; nil

(infix 3 + 5 * 8)
; =&gt; 43

(infix (3 + 5) * 8)
; =&gt; 64
</code></pre>
<p>You can also use <code>$=</code> as a short alias for <code>infix</code>, like this for example:</p>
<pre><code class="clojure">(refer 'infix.macros :only '[$=])
; =&gt; nil

($= 3 + 5 * 8)
; =&gt; 43
</code></pre>
<p>All of the examples below should work if you replace <code>infix</code> by <code>$=</code>.</p>
<p>Some <code>Math</code> functions have been aliased (see <a href="#aliased-operators--functions">below</a> for full list), so nullary and unary-argument functions can be used as follows:</p>
<pre><code class="clojure">(infix √(5 * 5))
; =&gt; 5.0

(infix √ 121)
; =&gt; 11.0

(infix 2 ** 6)
; =&gt; 64.0

(def t 0.324)
; =&gt; #'user/t

(infix sin(2 * t) + 3 * cos(4 * t))
; =&gt; 1.4176457261295824

(infix rand() * 3)
; =&gt; 0.5544039436207262
</code></pre>
<h4><a href="#debugging" name="debugging"></a>Debugging</h4>
<p>It may be the case that you encounter some esoteric errors emitted from the library trying to rephrase expressions from infix to prefix. Use <code>macroexpand-1</code> to show how the expression would be rewritten, and if necessary file an <a href="https://github.com/rm-hull/infix/issues/new">issue</a>.</p>
<pre><code class="clojure">(macroexpand-1 '(infix sin(2 * t) + 3 * cos(4 * t))
; =&gt; (+ (Math/sin (* 2 t)) (* 3 (Math/cos (* 4 t))))
</code></pre>
<h3><a href="#usage-in-clojurescript-projects" name="usage-in-clojurescript-projects"></a>Usage in ClojureScript projects</h3>
<p>The <code>infix</code> macro may be used to expand infix expressions in ClojureScript code by adding the require-macros directive to a namespace, for example:</p>
<pre><code class="clojure">(ns my.clojurescript.project
  (:require-macros [infix.macros :refer [infix]]))
</code></pre>
<h3><a href="#evaluating-infix-expressions-dynamically-from-a-string" name="evaluating-infix-expressions-dynamically-from-a-string"></a>Evaluating infix expressions dynamically from a string</h3>
<p>A function can created at runtime from an expression held in a string as follows. When building from a string, a number of binding arguments should be supplied, corresponding to any variable that may be used in the string expression, for example:</p>
<pre><code class="clojure">(def hypot
  (from-string [x y]
    "sqrt(x**2 + y**2)"))
; =&gt; #'user/hypot

(hypot 3 4)
; =&gt; 5
</code></pre>
<p><code>from-string</code> is deliberately designed to <em>look</em> like an anonymous function definition, mainly because that is more-or-less what it is. In effect, this is equivalent to creating the following function:</p>
<pre><code class="clojure">(def hypot
  (fn [x y]
    (infix sqrt(x ** 2 + y ** 2))))
</code></pre>
<p>However, it does so without recourse to <code>eval</code> and <code>read-string</code> - instead it is built using our <a href="https://github.com/rm-hull/jasentaa">old friend</a>, the monadic parser-combinator, with an EBNF grammar (implementing the infix notation) and a restricted base environment of math functions, as outlined in the next section.</p>
<p>The <code>base-env</code> may be extended with any number of key/value pairs (where keys are keywords) and values may either be values or functions, to provide the required extensions. When referenced in the string it is <strong>not</strong> necessary to prefix the name with a colon.</p>
<pre><code class="clojure">(def extended-env
  (merge
    base-env
    {:rad (fn [deg] (infix deg * π / 180))
     :hypot hypot}))
; =&gt; user/extended-env

(def rhs-triangle-height
  (from-string [base angle]
    extended-env
    "tan(rad(angle)) * base"))
; =&gt; user/rhs-triangle-height

(rhs-triangle-height 10 45)
; =&gt; 9.9999999999998
</code></pre>
<p>Obviously, a function that was previously created from a string can also referenced in a subsequent function definition:</p>
<pre><code class="clojure">(def hypot2
  (from-string [x y]
    extended-env
    "hypot(x, y) ** 2"))
; =&gt; user/hypot2

(hypot2 5 12)
; =&gt; 169.0
</code></pre>
<h3><a href="#aliased-operators-functions" name="aliased-operators-functions"></a>Aliased Operators &amp; Functions</h3>
<table>
  <thead>
    <tr>
      <th>Alias </th>
      <th>Operator </th>
      <th> </th>
      <th>Alias </th>
      <th>Operator </th>
      <th> </th>
      <th>Alias </th>
      <th>Operator </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&amp;&amp; </td>
      <td>and </td>
      <td> </td>
      <td>abs </td>
      <td>Math/abs </td>
      <td> </td>
      <td>sin </td>
      <td>Math/sin </td>
    </tr>
    <tr>
      <td>|| </td>
      <td>or </td>
      <td> </td>
      <td>signum </td>
      <td>Math/signum </td>
      <td> </td>
      <td>cos </td>
      <td>Math/cos </td>
    </tr>
    <tr>
      <td>== </td>
      <td>= </td>
      <td> </td>
      <td>** </td>
      <td>Math/pow </td>
      <td> </td>
      <td>tan </td>
      <td>Math/tan </td>
    </tr>
    <tr>
      <td>!= </td>
      <td>not= </td>
      <td> </td>
      <td>exp </td>
      <td>Math/exp </td>
      <td> </td>
      <td>asin </td>
      <td>Math/asin </td>
    </tr>
    <tr>
      <td>% </td>
      <td>mod </td>
      <td> </td>
      <td>log </td>
      <td>Math/log </td>
      <td> </td>
      <td>acos </td>
      <td>Math/acos </td>
    </tr>
    <tr>
      <td>&lt;&lt;</td>
      <td>bit-shift-left </td>
      <td> </td>
      <td>e </td>
      <td>Math/E </td>
      <td> </td>
      <td>atan </td>
      <td>Math/atan </td>
    </tr>
    <tr>
      <td>&gt;&gt;</td>
      <td>bit-shift-right </td>
      <td> </td>
      <td>π </td>
      <td>Math/PI </td>
      <td> </td>
      <td>sinh </td>
      <td>Math/sinh </td>
    </tr>
    <tr>
      <td>! </td>
      <td>not </td>
      <td> </td>
      <td>sqrt </td>
      <td>Math/sqrt </td>
      <td> </td>
      <td>cosh </td>
      <td>Math/cosh </td>
    </tr>
    <tr>
      <td>&amp; </td>
      <td>bit-and </td>
      <td> </td>
      <td>√ </td>
      <td>Math/sqrt </td>
      <td> </td>
      <td>tanh </td>
      <td>Math/tanh </td>
    </tr>
    <tr>
      <td>| </td>
      <td>bit-or </td>
      <td> </td>
      <td>root </td>
      <td>b √ a </td>
      <td> </td>
      <td>sec </td>
      <td>Secant </td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>φ </td>
      <td>Golden ratio </td>
      <td> </td>
      <td>csc </td>
      <td>Cosecant </td>
    </tr>
    <tr>
      <td>gcd     </td>
      <td>Greatest common divisor </td>
      <td>  </td>
      <td>fact   </td>
      <td>Factorial       </td>
      <td>  </td>
      <td>cot   </td>
      <td>Cotangent       </td>
    </tr>
    <tr>
      <td>lcm </td>
      <td>Least common multiple </td>
      <td> </td>
      <td>∑ </td>
      <td>Sum </td>
      <td> </td>
      <td>asec </td>
      <td>Arcsecant </td>
    </tr>
    <tr>
      <td>rand </td>
      <td>Random number generator </td>
      <td> </td>
      <td>∏ </td>
      <td>Product </td>
      <td> </td>
      <td>acsc </td>
      <td>Arccosecant </td>
    </tr>
    <tr>
      <td>randInt </td>
      <td>Random int between 0..n </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>acot </td>
      <td>Arccotangent </td>
    </tr>
  </tbody>
</table>
<h2><a href="#ebnf-grammar-rules" name="ebnf-grammar-rules"></a>EBNF Grammar Rules</h2>
<p>The <code>from-string</code> macro parses infix expressions based on the EBNF <a href="https://github.com/rm-hull/infix/blob/master/src/infix/grammar.clj">grammar rules</a> as follows:</p>
<ul>
  <li>
  <p><em><strong>&lt;expression&gt;</strong> ::= term { addop term }.</em></p></li>
  <li>
  <p><em><strong>&lt;term&gt;</strong> ::= factor { mulop factor }.</em></p></li>
  <li>
  <p><em><strong>&lt;factor&gt;</strong> ::= “(” expression “)” | var | number | function.</em></p></li>
  <li>
  <p><em><strong>&lt;addop&gt;</strong> ::= “+” | “-” | “|” | “&amp;”.</em></p></li>
  <li>
  <p><em><strong>&lt;mulop&gt;</strong> ::= “*” | “/” | “÷” | “**” | “%” | “&gt;&gt;” | “&gt;&gt;&gt;” | “&lt;&lt;”.</em></p></li>
  <li>
  <p><em><strong>&lt;function&gt;</strong> ::= envref expression | envref “(” &lt;empty&gt; | expression { “,” expression } “)”.</em></p></li>
  <li>
  <p><em><strong>&lt;envref&gt;</strong> ::= letter { letter | digit | "</em>" }._</p></li>
  <li>
  <p><em><strong>&lt;var&gt;</strong> ::= envref.</em></p></li>
  <li>
  <p><em><strong>&lt;number&gt;</strong> ::= integer | decimal | rational | binary | hex</em></p></li>
  <li>
  <p><em><strong>&lt;binary&gt;</strong> :: = [ “-” ] “0b” { “0” | “1” }.</em></p></li>
  <li>
  <p><em><strong>&lt;hex&gt;</strong> :: = [ “-” ] “0x” | “#” { “0” | … | “9” | “A” | … | “F” | “a” | … | “f” }.</em></p></li>
  <li>
  <p><em><strong>&lt;integer&gt;</strong> :: = [ “-” ] digits.</em></p></li>
  <li>
  <p><em><strong>&lt;decimal&gt;</strong> :: = [ “-” ] digits “.” digits.</em></p></li>
  <li>
  <p><em><strong>&lt;rational&gt;</strong> :: = integer “/” digits.</em></p></li>
  <li>
  <p><em><strong>&lt;letter&gt;</strong> ::= “A” | “B” | … | “Z” | “a” | “b” | … | “z”.</em></p></li>
  <li>
  <p><em><strong>&lt;digit&gt;</strong> ::= “0” | “1” | … | “8” | “9”.</em></p></li>
  <li>
  <p><em><strong>&lt;digits&gt;</strong> ::= digit { digit }.</em></p></li>
</ul></div></div></div></body></html>